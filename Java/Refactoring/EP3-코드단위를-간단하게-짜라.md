# 유지보수와 리팩토링
## EP 3. 코드 단위를 간단하게 짜라

* 단위당 분기점은 4개로 제한한다.
* 유지보수 가능한 형태로 만들려면 복잡도(complexity)에 제한을 두어야 한다. 그러기 위해서는 복잡도를 측정할 수 있어야하는데 가장 일반적인 방법은 코드 조각을 지나는 가능한 경로의 개수를 세어보는 것이다.
* 분기점(branch point) 개수를 세어보면 경로 개수를 명확히 밝혀 낼 수 있는데, 여기서 분기점이란 한 가지 이상의 방향으로 실행 흐름을 나누어 진행하는 조건문을 말한다. (if와 switch같이)
* 단위 분기점 개수는 그 단위의 모든 분기점으로 만들어진 경로를 전부 커버하기 위해 필요한 최소한의 경로 개수이고 이를 분기 커버리지(branch coverage)라고 한다. 그러나 단위의 모든 경로를 계산하다 보면 분기 간 순서 문제 때문에 조합 효과(combinatory effects)가 발생할 수 있다. 모든 분기를 조합한 개수는 결국 단위 실행 경로(execution paths), 즉 단위를 지나는 경로의 최대 개수이다.
* 복잡도는 분기점 개수의 +1 이며 이 값을 순환 복잡도(cyclomatic complexity) 또는 맥캐브 복잡도(McCabe complexity)라고 한다. 즉 "분기점 개수를 4개로 제한하라"는 가이드라인은 "맥캐브 복잡도를 5로 제한하라"는 말이다.
* 이 값은 각각의 경로가 다른 경로가 커버하지 못한 부분을 지날 수 있게끔, 단위를 커버하는데 필요한 최소한의 테스트 개수를 뜻한다.




### 단위를 간단하게 짜야하는 이유
* 간단한 단위는 복잡한 단위보다 이해하기 쉽고 그래서 수정하기도 쉽다.
* 간단한 단위는 테스트하기 쉽다.


### 분기점에 해당하는 문과 연산자
* if
* case
* ?
* &&, ||
* while
* for
* catch


### 해결방안
* 거의 독립적인 코드 블록 서너 개가 뭉쳐있으면 메서드 추출 패턴으로 리팩터링할 수 있다.
* 조건들이 서로 배타적인 관계라면 switch문을 쓰고 그렇지 않을때 if를 사용하면 if-then-else문 체인을 해결할 수 있다.
* 길어진 switch문은 객체와 매핑하는 Map 자료구조를 사용해 조건을 다형성으로 대체(Replace Conditional with Polymorphism) 패턴으로 리팩터링할 수 있다.
* 중첩 조건문을 케이스 별로 구분해 각각 return문을 넣어 제거하는 중첩문을 보호절로 대체(Replace Nested Conditional with Guard Clauses)패턴으로 리팩토링 할 수 있다.

<br>

* 도메인이 복잡하다고 기술적으로 복잡하게 구현해야 하는 건 아니다. 다양한 조건과 예외 사항을 처리하는 시스템이라면 간단한 디폴트 프로세스를 구현하고 예외를 명시적으로 모델링하는 것도 방법이다.
* 메서드 하나를 여러 메서드로 리팩토링 한다고 전체 맥캐브 복잡도가 줄어들진 않지만 유지보수 관점에서 테스트하기 쉽고 읽고 분석하기 편해진다. 새로 작성한 코드의 실패한 테스트의 근본 원인을 쉽게 밝혀낼 수 있다.



### 정리
기능과 케이스를 이해하기 쉽게 명명한, 많아야 분기점이 4개 이하인, 간단한 단위로 코딩하라.

 