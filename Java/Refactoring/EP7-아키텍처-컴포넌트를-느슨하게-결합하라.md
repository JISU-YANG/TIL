# 유지보수와 리팩토링
## EP 7. 아키텍처 컴포넌트를 느슨하게 결합하라

> 최상위 수준의 컴포넌트 간의 결합도를 낮춰라.





컴포넌트는 다른 컴포넌트로 들어가는 지점을 최대한 제한함으로써 구분해야 하며 컴포넌트끼리 한정된 정보만 공유하도록 해야한다. 이런식으로 메서드 구현 세부를 감추면(또는 캡슐화하면) 시스템을 점점 더 모듈화할 수 있다.

<br>

동일한 컴포넌트에 있는 모듈이 호출해도 모듈 수준에서 바라보면 사실상 모듈 결합(Module Coupling)이 생긴 것이다.




### 긍정적인 호출
* 내부 호출(Internal Call): 호출하는 모듈끼리 같은 컴포넌트의 구성 요소라서 긴밀히 연관된 기능을 구현하며 내부 로직은 베일에 싸여 있다.
* 유출 호출(Outgoing Call): 다른 컴포넌트에 할 일을 위임하는 형태로 대외적인 의존성이 발생한다. 구분되는 관심사를 위임하는 것은 바람직하다.


### 부정적인 호출
* 유입 호출(Incoming Call): 인터페이스를 통해 다른 컴포넌트에 기능을 제공하는 호출로 가능한 제한해야한다. 컴포넌트 내부 코드는 가능한 캡슐화해서 다른 컴포넌트가 직접 불러 실행하지 못하게 막아야한다.
* 떠넘김 코드(Throughput Code): 들어오는 호출을 접수해서 다른 컴포넌트에 위임을 하는 코드이다. 컴포넌트 별로 책임이 올바로 나뉘지 않은 것이다.


### 컴포넌트 의존성이 낮을 경우 장점
1. 분리해서 유지보수 할 수 있다.
2. 유지보수 책임을 분담할 수있다.
3. 테스트하기 쉽다.



### 가이드라인
* 컴포넌트의 인터페이스에 해당하는모듈의 크기를 제한한다.
* 상위 수준에서 컴포넌트 인터페이스를 추상화한다.
* 떠넘김 코드는 쓰지 않는다.


### TIP
* 추상 팩토리(Abstract Factory) 디자인 패턴을 사용한다.
* 제어 역전(Inversion of Control), 의존성 주입(Dependency Injection) 프레임워크를 이용한다.




### 의견
* Q. 컴포넌트가 하도 얽혀 있어서 의존성을 바로잡을 길이 없다.  
  A. 테스트 용이성과 정확한 기능 파악에 가장 심각한 영향을 미치는 스루풋 부류의 모듈을 분석해라.
* Q. 고칠 시간이 없다.  
  A. 테스트 하기 곤란해지고, 이슈 대비 필요한 공수를 산출해보면 직시 할  것이다.
* Q. 떠넘김 자체가 요건이다.  
  A. 일부러 중간 계층을 두는 아키텍처도 있지만 확실히 구분을 하면 된다.